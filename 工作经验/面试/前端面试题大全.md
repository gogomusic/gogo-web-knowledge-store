## 必会题
### 闭包 - Closure
**概念**：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域

**作用**：实现数据（变量）的私有化

**注意**：

1. 闭包一定要return吗？  

>不一定，在函数外部需要使用函数内部的变量时，才需要return

2. 闭包一定有内存泄露吗？

>不一定

**示例**：以下代码构成了一个闭包，但是既没有return，也没有内存泄漏

```js
function outer () {
  const a = 1
  function fn () {
    console.log(a)
  }
  fn()
}
outer()
```

**示例**：数据私有化、内存泄露
```js
function fn1 () {
  let i = 0
  function fn2 () {
    i++
    console.log(i);
  }
  return fn2
}
const ff = fn1()
ff()//1
ff()//2
i = 100//外部无法更fn1内部的i的值
ff()//3
```
上面的例子中，变量`i`作为函数`fn1`的私有变量，不能被外部更改，但在函数`fn1`执行完毕后，`i`也不会被垃圾回收。此时发生了内存泄露。借助于垃圾回收机制的标记清除法可以看出：

1. `ff`是一个全局变量，代码执行完毕不会**立即销毁**
2. `ff`使用了`fn1`函数
3. `fn1`使用了`fn2`函数
4. `fn2`使用了变量`i`
5. `i`被引用，所以不会被垃圾回收，会一直存在于内存中

此时，闭包引起了内存泄露

>⚠ 闭包造成的内存泄露并不一定非要去手动回收